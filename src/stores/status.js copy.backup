import { defineStore } from 'pinia'
import { useNeedsQueueStore } from './needs/needsQueue.js'
import { useCageStore } from './cage.js'

export const useStatusStore = defineStore('status', {
  state: () => ({
    // Message configurations for different urgency levels
    // Individual need stores will provide their own message configs
    messageConfig: {},
        messages: {
          normal: [
            'Getting a bit peckish...',
            'Sniffing around for food...',
            'Time for a snack?'
          ],
          urgent: [
            'I\'m getting really hungry!',
            'Where\'s the food?',
            'Need food soon!',
            'My tummy is rumbling...'
          ],
          critical: [
            'I\'m STARVING!',
            'FEED ME NOW!',
            'I need food immediately!',
            'This guinea pig is famished!'
          ]
        },
        emoji: 'üçΩÔ∏è',
        intervals: {
          normal: 12000,    // 12 seconds
          urgent: 8000,     // 8 seconds  
          critical: 5000    // 5 seconds
        }
      },
      thirst: {
        messages: {
          normal: [
            'Could use some water...',
            'Feeling a bit parched...'
          ],
          urgent: [
            'Getting really thirsty!',
            'Need water soon!'
          ],
          critical: [
            'I\'m SO thirsty!',
            'Water needed urgently!'
          ]
        },
        emoji: 'üíß',
        intervals: {
          normal: 10000,    // 10 seconds
          urgent: 6000,     // 6 seconds
          critical: 4000    // 4 seconds
        }
      },
      chew: {
        messages: {
          normal: [
            'My teeth need some work...',
            'Looking for something to chew...'
          ],
          urgent: [
            'Need to chew something!',
            'My teeth are getting too long!'
          ],
          critical: [
            'MUST CHEW SOMETHING NOW!',
            'Teeth emergency!'
          ]
        },
        emoji: 'ü¶∑',
        intervals: {
          normal: 15000,    // 15 seconds
          urgent: 10000,    // 10 seconds
          critical: 7000     // 7 seconds
        }
      },
      enrichment: {
        messages: {
          normal: [
            'Feeling a bit bored...',
            'Could use some fun...',
            'Time to play?'
          ],
          urgent: [
            'I\'m getting restless!',
            'Need some entertainment!'
          ],
          critical: [
            'I\'m SO BORED!',
            'Need stimulation NOW!'
          ]
        },
        emoji: 'üéæ',
        intervals: {
          normal: 14000,    // 14 seconds
          urgent: 9000,     // 9 seconds
          critical: 6000     // 6 seconds
        }
      },
      shelter: {
        messages: {
          normal: [
            'Looking for a cozy spot...',
            'Could use some shelter...'
          ],
          urgent: [
            'Need somewhere safe!',
            'Looking for hiding place!'
          ],
          critical: [
            'I feel so exposed!',
            'Need shelter RIGHT NOW!'
          ]
        },
        emoji: 'üè†',
        intervals: {
          normal: 16000,    // 16 seconds
          urgent: 11000,    // 11 seconds
          critical: 8000     // 8 seconds
        }
      },
      hygiene: {
        messages: {
          normal: [
            'Feeling a bit messy...',
            'Could use some grooming...'
          ],
          urgent: [
            'I\'m getting quite dirty!',
            'Really need cleaning!'
          ],
          critical: [
            'I\'m absolutely filthy!',
            'HYGIENE EMERGENCY!'
          ]
        },
        emoji: 'üõÅ',
        intervals: {
          normal: 18000,    // 18 seconds
          urgent: 12000,    // 12 seconds
          critical: 9000     // 9 seconds
        }
      }
    },
    
    // Current urgency messages and their timers
    activeMessages: new Map(), // Map of needType -> { message, timer, lastShown }
    
    // Current priority message to display
    currentMessage: null,
    
    // Message history to avoid repetition
    messageHistory: new Map(), // Map of needType -> [recent messages]
    historyLength: 3, // How many recent messages to remember per need
    
    // General settings
    enabled: true,
    globalCooldown: 100, // Minimum time between any messages (0.1 seconds)
    lastMessageTime: 0,
    
    // Update timer management
    updateTimer: null,
    updateInterval: 1000, // Update every 1 second
    
    // Initialization flag
    _initialized: false
  }),

  getters: {
    // Get the configuration for a specific need type
    getNeedConfig: (state) => (needType) => {
      return state.messageConfig[needType] || null
    },

    // Get all currently active urgency messages
    getActiveUrgencyMessages: (state) => {
      const messages = []
      // Ensure activeMessages is a Map
      const activeMap = state.activeMessages instanceof Map ? 
        state.activeMessages : 
        new Map(Object.entries(state.activeMessages || {}))
      
      for (const [needType, data] of activeMap.entries()) {
        messages.push({
          needType,
          message: data.message,
          emoji: state.messageConfig[needType]?.emoji || '‚ö†Ô∏è',
          urgency: data.urgency,
          lastShown: data.lastShown
        })
      }
      return messages.sort((a, b) => b.urgency - a.urgency)
    },

    // Get the highest priority message to display
    getCurrentPriorityMessage: (state) => {
      if (!state.currentMessage) return null
      
      const config = state.messageConfig[state.currentMessage.needType]
      return {
        ...state.currentMessage,
        emoji: state.currentMessage.emoji || config?.emoji || '‚ö†Ô∏è'
      }
    },

    // Get the current status display (message and emoji) based on context
    getCurrentStatusDisplay: (state) => (context) => {
      // context should include: guineaPigStore, cageStore, poopStore, marketStore
      const { guineaPigStore, cageStore, poopStore, marketStore } = context
      const now = Date.now()
      
      // Check for temporary messages first (highest priority)
      const urgencyMessage = state.currentMessage
      if (urgencyMessage && urgencyMessage.isTemporary) {
        const config = state.messageConfig[urgencyMessage.needType]
        return {
          message: urgencyMessage.message,
          emoji: urgencyMessage.emoji || config?.emoji || '‚ö†Ô∏è'
        }
      }
      
      // Skip the cooldown content message - let other messages show immediately
      
      const { x, y } = cageStore.guineaPigPos
      
      // Check if guinea pig is on fresh poop (high priority)
      const poopAtPosition = poopStore.getPoopAtPosition(x, y)
      if (poopAtPosition) {
        const poopAge = Date.now() - poopAtPosition.timestamp
        const isFreshPoop = poopAge < 2000
        if (isFreshPoop) {
          return {
            message: 'The guinea pig just made a poop!',
            emoji: 'üí©'
          }
        }
        // Old poop message is handled by temporary messages now
      }
      
      // Check if guinea pig is on an item (medium priority)
      const currentItem = cageStore.items.find(item => item.x === x && item.y === y)
      if (currentItem) {
        const itemData = marketStore.getItemData(currentItem.name)
        if (itemData && itemData.actionWord) {
          const itemName = currentItem.name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
          return {
            message: `The guinea pig is ${itemData.actionWord} the ${itemName}.`,
            emoji: marketStore.getItemEmoji(currentItem.name)
          }
        }
      }
      
      // Check for urgent/critical need messages (medium-low priority)
      if (urgencyMessage && (urgencyMessage.urgencyLevel === 'critical' || urgencyMessage.urgencyLevel === 'urgent')) {
        const config = state.messageConfig[urgencyMessage.needType]
        return {
          message: urgencyMessage.message,
          emoji: urgencyMessage.emoji || config?.emoji || '‚ö†Ô∏è'
        }
      }
      
      // Default to guinea pig state (low priority)
      // Show normal need messages more frequently (40% chance when guinea pig is sitting)
      if (urgencyMessage && urgencyMessage.urgencyLevel === 'normal' && guineaPigStore.sitting && Math.random() < 0.4) {
        const config = state.messageConfig[urgencyMessage.needType]
        return {
          message: urgencyMessage.message,
          emoji: urgencyMessage.emoji || config?.emoji || '‚ö†Ô∏è'
        }
      }
      
      // Show content message during cooldown after reactions (medium-low priority)
      if (now - state.lastMessageTime < 2000 && now - state.lastMessageTime > 500) {
        return {
          message: 'Guinea pig is content',
          emoji: 'üòå'
        }
      }
      
      return {
        message: guineaPigStore.currentMessage,
        emoji: guineaPigStore.currentEmoji
      }
    }
  },

  actions: {
    // Initialize the status system
    initialize() {
      if (!this._initialized) {
        console.log('üîç PLAN: Initializing status system')
        this._initialized = true
        if (this.enabled) {
          this.startUpdates()
        }
      }
    },

    // Update urgency messages based on current needs
    updateUrgencyMessages() {
      // Auto-initialize if not done yet
      if (!this._initialized) {
        this.initialize()
      }
      console.log('üîç PLAN: updateUrgencyMessages called, enabled:', this.enabled)
      
      if (!this.enabled) {
        console.log('üîç PLAN: Status system disabled, skipping updates')
        return
      }

      // Check if game is paused - don't update messages when paused
      const cageStore = useCageStore()
      if (cageStore.paused) {
        console.log('üîç PLAN: Skipping message updates - game is paused')
        return
      }

      const needsQueueStore = useNeedsQueueStore()
      const allNeedsStatus = needsQueueStore.allNeedsStatus
      
      // Process each need type
      for (const [needType, status] of Object.entries(allNeedsStatus)) {
        const config = this.messageConfig[needType]
        if (!config) {
          continue
        }

        // Determine urgency level
        let urgencyLevel = 'normal'
        let interval = config.intervals.normal

        if (status.isCritical) {
          urgencyLevel = 'critical'
          interval = config.intervals.critical
        } else if (status.isUrgent) {
          urgencyLevel = 'urgent' 
          interval = config.intervals.urgent
        } else if (status.urgency < 10) {
          // Don't show messages for very low urgency (below 10)
          this.clearNeedMessages(needType)
          continue
        }

        // Check if we should show a message for this need
        this.scheduleNeedMessage(needType, urgencyLevel, interval, status.urgency)
      }
    },

    // Schedule a message for a specific need
    scheduleNeedMessage(needType, urgencyLevel, interval, urgency) {
      // Ensure activeMessages is a Map
      if (!(this.activeMessages instanceof Map)) {
        this.activeMessages = new Map(Object.entries(this.activeMessages || {}))
      }
      
      const existing = this.activeMessages.get(needType)
      const now = Date.now()

      // If already scheduled with same urgency level, don't reschedule
      if (existing && existing.urgencyLevel === urgencyLevel) {
        return
      }

      // Clear existing timer if any
      if (existing?.timer) {
        clearInterval(existing.timer)
      }

      // Schedule new message timer
      const timer = setInterval(() => {
        this.showNeedMessage(needType, urgencyLevel, urgency)
      }, interval)

      // Show first message immediately
      const initialDelay = 0

      setTimeout(() => {
        this.showNeedMessage(needType, urgencyLevel, urgency)
      }, initialDelay)

      // Store the message info
      this.activeMessages.set(needType, {
        timer,
        urgencyLevel,
        urgency,
        message: null,
        lastShown: 0
      })
    },

    // Show a specific need message
    showNeedMessage(needType, urgencyLevel, urgency) {
      const now = Date.now()
      
      console.log(`üîç PLAN: Attempting to show ${needType} message (${urgencyLevel}, urgency: ${Math.round(urgency)})`)
      
      // Check global cooldown
      if (now - this.lastMessageTime < this.globalCooldown) {
        console.log(`‚è∞ DELAY: Message blocked by global cooldown (${this.globalCooldown}ms)`)
        return
      }

      const config = this.messageConfig[needType]
      if (!config) {
        console.log(`üîç PLAN: No config found for need type: ${needType}`)
        return
      }

      // Get available messages for this urgency level
      const messages = config.messages[urgencyLevel] || []
      if (messages.length === 0) {
        console.log(`üîç PLAN: No messages available for ${needType} at ${urgencyLevel} level`)
        return
      }
      console.log(`üîç PLAN: ${messages.length} potential messages for ${needType}:`, messages)

      // Ensure messageHistory is a Map
      if (!(this.messageHistory instanceof Map)) {
        this.messageHistory = new Map(Object.entries(this.messageHistory || {}))
      }
      
      // Get message history for this need to avoid repetition
      const history = this.messageHistory.get(needType) || []
      
      // Filter out recently shown messages
      let availableMessages = messages.filter(msg => !history.includes(msg))
      console.log(`üîç PLAN: ${availableMessages.length} messages available after filtering out recent ones`)
      
      // If all messages were recently used, use all messages
      if (availableMessages.length === 0) {
        availableMessages = [...messages]
        this.messageHistory.set(needType, []) // Clear history
        console.log(`üîç PLAN: All messages were recent, cleared history and using all ${availableMessages.length} messages`)
      }

      // Pick a random message
      const message = availableMessages[Math.floor(Math.random() * availableMessages.length)]
      console.log(`üì¢ SHOW: Selected message for ${needType}: "${message}"`)

      // Update message history
      history.push(message)
      if (history.length > this.historyLength) {
        history.shift()
      }
      this.messageHistory.set(needType, history)

      // Set as current message
      this.currentMessage = {
        needType,
        message,
        urgency,
        urgencyLevel,
        timestamp: now
      }
      console.log(`üì¢ SHOW: Current message set to ${needType} (urgency: ${Math.round(urgency)})`)

      // Update active message data
      // Ensure activeMessages is a Map
      if (!(this.activeMessages instanceof Map)) {
        this.activeMessages = new Map(Object.entries(this.activeMessages || {}))
      }
      
      const activeData = this.activeMessages.get(needType)
      if (activeData) {
        activeData.message = message
        activeData.lastShown = now
      }

      this.lastMessageTime = now
    },

    // Clear messages for a specific need
    clearNeedMessages(needType) {
      // Ensure activeMessages is a Map
      if (!(this.activeMessages instanceof Map)) {
        this.activeMessages = new Map(Object.entries(this.activeMessages || {}))
      }
      
      const existing = this.activeMessages.get(needType)
      if (existing?.timer) {
        clearInterval(existing.timer)
      }
      this.activeMessages.delete(needType)
      
      // Clear from current message if it matches
      if (this.currentMessage?.needType === needType) {
        this.currentMessage = null
      }
    },

    // Clear all urgency messages
    clearAllMessages() {
      // Ensure activeMessages is a Map
      if (!(this.activeMessages instanceof Map)) {
        this.activeMessages = new Map(Object.entries(this.activeMessages || {}))
      }
      
      for (const [needType] of this.activeMessages.entries()) {
        this.clearNeedMessages(needType)
      }
      this.currentMessage = null
    },

    // Configure message settings for a need type
    configureNeedMessages(needType, config) {
      if (!this.messageConfig[needType]) {
        this.messageConfig[needType] = {
          messages: { normal: [], urgent: [], critical: [] },
          emoji: '‚ö†Ô∏è',
          intervals: { normal: 12000, urgent: 8000, critical: 5000 }
        }
      }
      
      // Merge the configuration
      Object.assign(this.messageConfig[needType], config)
    },

    // Add custom messages for a need type and urgency level
    addCustomMessages(needType, urgencyLevel, messages) {
      if (!this.messageConfig[needType]) {
        this.configureNeedMessages(needType, {})
      }
      
      if (!Array.isArray(messages)) {
        messages = [messages]
      }
      
      this.messageConfig[needType].messages[urgencyLevel].push(...messages)
    },

    // Update intervals for a need type
    updateIntervals(needType, intervals) {
      if (this.messageConfig[needType]) {
        Object.assign(this.messageConfig[needType].intervals, intervals)
        
        // Ensure activeMessages is a Map
        if (!(this.activeMessages instanceof Map)) {
          this.activeMessages = new Map(Object.entries(this.activeMessages || {}))
        }
        
        // If this need has active messages, reschedule them
        const active = this.activeMessages.get(needType)
        if (active) {
          const newInterval = intervals[active.urgencyLevel]
          if (newInterval && active.timer) {
            clearInterval(active.timer)
            active.timer = setInterval(() => {
              this.showNeedMessage(needType, active.urgencyLevel, active.urgency)
            }, newInterval)
          }
        }
      }
    },

    // Enable/disable the status system
    setEnabled(enabled) {
      this.enabled = enabled
      if (!enabled) {
        this.clearAllMessages()
        this.stopUpdates()
      } else {
        this.startUpdates()
      }
    },

    // Start periodic updates
    startUpdates() {
      console.log('üîç PLAN: Starting status system updates, interval:', this.updateInterval)
      
      // Clear any stale timer from persisted state
      if (this.updateTimer) {
        console.log('üîç PLAN: Clearing existing update timer')
        clearInterval(this.updateTimer)
        this.updateTimer = null
      }
      
      // Always create a fresh timer
      this.updateTimer = setInterval(() => {
        if (this.enabled) {
          this.updateUrgencyMessages()
        }
      }, this.updateInterval)
      
      console.log('üîç PLAN: Update timer created with ID:', this.updateTimer)
      
      // Do initial update
      if (this.enabled) {
        this.updateUrgencyMessages()
      }
    },

    // Stop periodic updates
    stopUpdates() {
      if (this.updateTimer) {
        clearInterval(this.updateTimer)
        this.updateTimer = null
      }
    },

    // Reset message history
    resetMessageHistory() {
      // Ensure messageHistory is a Map
      if (!(this.messageHistory instanceof Map)) {
        this.messageHistory = new Map(Object.entries(this.messageHistory || {}))
      }
      this.messageHistory.clear()
    },

    // Show a temporary message that overrides other messages for a short time
    showTemporaryMessage(message, emoji = '‚ö†Ô∏è', duration = 2000) {
      const now = Date.now()
      
      console.log(`üì¢ SHOW: Temporary message: "${message}" ${emoji} for ${duration}ms`)
      
      // Set as current message with high priority
      this.currentMessage = {
        needType: 'temporary',
        message,
        urgency: 999, // Very high urgency to override other messages
        urgencyLevel: 'temporary',
        timestamp: now,
        emoji,
        isTemporary: true
      }
      
      // Clear the message after the specified duration
      setTimeout(() => {
        // Only clear if this is still the current temporary message
        if (this.currentMessage?.isTemporary && this.currentMessage.timestamp === now) {
          this.currentMessage = null
          console.log(`üì¢ SHOW: Temporary message cleared after ${duration}ms`)
        }
      }, duration)
      
      // Extend the global cooldown to prevent other messages from showing immediately after
      // Add a buffer to the cooldown based on the message duration
      this.lastMessageTime = now + duration + 50 // Extra 0.05 second buffer
    },

    // Get debug info
    getDebugInfo() {
      // Ensure Maps are proper Maps
      if (!(this.activeMessages instanceof Map)) {
        this.activeMessages = new Map(Object.entries(this.activeMessages || {}))
      }
      if (!(this.messageHistory instanceof Map)) {
        this.messageHistory = new Map(Object.entries(this.messageHistory || {}))
      }
      
      return {
        enabled: this.enabled,
        activeMessagesCount: this.activeMessages.size,
        currentMessage: this.currentMessage,
        lastMessageTime: this.lastMessageTime,
        messageHistorySize: this.messageHistory.size
      }
    }
  },

  persist: {
    paths: ['messageConfig', 'enabled', 'globalCooldown', 'historyLength']
  }
})
